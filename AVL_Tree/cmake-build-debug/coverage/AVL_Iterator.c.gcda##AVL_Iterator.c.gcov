        -:    0:Source:/home/minerkow/Рабочий стол/CS_Programm/AVL_Tree/source/AVL_Iterator.c
        -:    0:Graph:/home/minerkow/Рабочий стол/CS_Programm/AVL_Tree/cmake-build-debug/CMakeFiles/AVL_Tree_Test.dir/source/AVL_Iterator.c.gcno
        -:    0:Data:/home/minerkow/Рабочий стол/CS_Programm/AVL_Tree/cmake-build-debug/CMakeFiles/AVL_Tree_Test.dir/source/AVL_Iterator.c.gcda
        -:    0:Runs:1
        -:    1:#include "../headers/AVL_Tree.h"
        -:    2:
        -:    3://*Return begin iterator
        -:    4:static struct Node_t* avlBeginIt_(struct AVL_Tree* avlTree);
        -:    5:
        -:    6://*Return end iterator
        -:    7:static struct Node_t* avlEndIt_(struct AVL_Tree* avlTree);
        -:    8:
        -:    9://*If the next element exists returns an iterator to it,
        -:   10://*else returns a empty iterator
        -:   11:static struct Node_t* avlNextIt_(struct Node_t* it);
        -:   12:
        -:   13://*If the prev element exists returns an iterator to it,
        -:   14://*else returns a empty iterator
        -:   15:static struct Node_t* avlPrevIt_(struct Node_t* it);
        -:   16:
        -:   17://-----------------------------------------------------------------------------------------------------------
        -:   18:
        -:   19:
        -:   20:struct Node_t {
        -:   21:    struct Node_t* left_;
        -:   22:    struct Node_t* right_;
        -:   23:    struct Node_t* prev_;
        -:   24:
        -:   25:    int height_;
        -:   26:
        -:   27:    int data_;
        -:   28:};
        -:   29:
        -:   30:struct AVL_Tree {
        -:   31:    struct Node_t* top_;
        -:   32:
        -:   33:    size_t size_;
        -:   34:};
        -:   35:
        -:   36://------------------------------------------------------------------------------------------
        -:   37:
       10:   38:bool avlEmptyIt(struct Node_t* it) {
       10:   39:    if (it == NULL) {
       10:   39-block  0
        5:   40:        return true;
        5:   40-block  0
        -:   41:    }
        5:   42:    return false;
        5:   42-block  0
        -:   43:}
        -:   44:
    99573:   45:struct Node_t* avlNextIt_(struct Node_t* it) {
   99573*:   46:    assert(it);
    99573:   46-block  0
    %%%%%:   46-block  1
    99573:   47:    if (it->prev_ == NULL) {
    99573:   47-block  0
       13:   48:        it = it->right_;
       13:   49:        struct Node_t* tmp = it;
       48:   50:        while (it != NULL) {
       13:   50-block  0
       48:   50-block  1
       35:   51:            tmp = it;
       35:   52:            it = it->left_;
       35:   52-block  0
        -:   53:        }
       13:   54:        return tmp;
       13:   54-block  0
        -:   55:    }
    99560:   56:    if (it->right_ != NULL) {
    99560:   56-block  0
    49681:   57:        it = it->right_;
    49681:   58:        struct Node_t* tmp = it;
   149172:   59:        while (it != NULL) {
    49681:   59-block  0
   149172:   59-block  1
    99491:   60:            tmp = it;
    99491:   61:            it = it->left_;
    99491:   61-block  0
        -:   62:        }
    49681:   63:        return tmp;
    49681:   63-block  0
        -:   64:    }
    49879:   65:    if (it->prev_->left_ == it) {
    49879:   65-block  0
    25297:   66:        it = it->prev_;
    25297:   67:        return it;
    25297:   67-block  0
        -:   68:    } else {
    24582:   69:        struct Node_t* tmp = it->prev_;
    49693:   70:        while (tmp->prev_ != NULL && tmp->prev_->left_ != tmp) {
    24582:   70-block  0
    49693:   70-block  1
    49681:   70-block  2
    25111:   71:            tmp = tmp->prev_;
    25111:   71-block  0
        -:   72:        }
    24582:   73:        if (tmp->prev_ == NULL) {
    24582:   73-block  0
       12:   74:            it = NULL;
       12:   75:            return it;
       12:   75-block  0
        -:   76:        }
    24570:   77:        it = tmp->prev_;
    24570:   78:        return it;
    24570:   78-block  0
        -:   79:    }
        -:   80:}
        -:   81:
    99578:   82:int avlGetDataByIt(struct Node_t* it) {
    99578:   83:    if (it == NULL) {
    99578:   83-block  0
        5:   84:        return NAN;
        5:   84-block  0
        -:   85:    }
    99573:   86:    return it->data_;
    99573:   86-block  0
        -:   87:}
        -:   88:
       15:   89:struct Node_t* avlBeginIt_(struct AVL_Tree* avlTree) {
      15*:   90:    assert(avlTree);
       15:   90-block  0
    %%%%%:   90-block  1
       15:   91:    if (!avlTree->top_) {
       15:   91-block  0
        1:   92:        return NULL;
        1:   92-block  0
        -:   93:    }
       14:   94:    struct Node_t* tmp = avlTree->top_;
       48:   95:    while (tmp->left_ != NULL) {
       14:   95-block  0
       48:   95-block  1
       34:   96:        tmp =tmp->left_;
       34:   96-block  0
        -:   97:    }
       14:   98:    return tmp;
       14:   98-block  0
        -:   99:}
        -:  100:
        2:  101:struct Node_t* avlEndIt_(struct AVL_Tree* avlTree) {
       2*:  102:    assert(avlTree);
        2:  102-block  0
    %%%%%:  102-block  1
        2:  103:    if (avlTree->top_ == NULL) {
        2:  103-block  0
        1:  104:        return NULL;
        1:  104-block  0
        -:  105:    }
        1:  106:    struct Node_t* tmp = avlTree->top_;
        1:  107:    while (tmp->right_ != NULL) {
        1:  107-block  0
        1:  107-block  1
    #####:  108:        tmp =tmp->right_;
    %%%%%:  108-block  0
        -:  109:    }
        1:  110:    return tmp;
        1:  110-block  0
        -:  111:}
        -:  112:
        3:  113:int avlGetMaxElem(struct AVL_Tree* avlTree) {
        3:  114:    if (!avlTree) {
        3:  114-block  0
        1:  115:        return NAN;
        1:  115-block  0
        -:  116:    }
        2:  117:    struct Node_t* it = avlEndIt_(avlTree);
        2:  117-block  0
        2:  118:    if (!it) {
        1:  119:        return NAN;
        1:  119-block  0
        -:  120:    }
        1:  121:    return it->data_;
        1:  121-block  0
        -:  122:}
        -:  123:
        3:  124:int avlGetMinElem(struct AVL_Tree* avlTree) {
        3:  125:    if (!avlTree) {
        3:  125-block  0
        1:  126:        return NAN;
        1:  126-block  0
        -:  127:    }
        2:  128:    struct Node_t* it = avlBeginIt_(avlTree);
        2:  128-block  0
        2:  129:    if (!it) {
        1:  130:        return NAN;
        1:  130-block  0
        -:  131:    }
        1:  132:    return it->data_;
        1:  132-block  0
        -:  133:}
        -:  134:
       16:  135:enum AvlError_t avlSaveInArray(struct AVL_Tree* avlTree, int* array, size_t lenArray) {
       16:  136:    if (!avlTree) {
       16:  136-block  0
        1:  137:        return AVLERR_NOT_INIT;
        1:  137-block  0
        -:  138:    }
       15:  139:    if (lenArray == 0) {
       15:  139-block  0
        1:  140:        return AVLERR_OK;
        1:  140-block  0
        -:  141:    }
       14:  142:    if (array == NULL) {
       14:  142-block  0
        1:  143:        return AVLERR_NULL_POINTER_ARG;
        1:  143-block  0
        -:  144:    }
       13:  145:    if (avlTree->top_ == NULL) {
       13:  145-block  0
        1:  146:        return AVLERR_OK;
        1:  146-block  0
        -:  147:    }
       12:  148:    struct Node_t* it = avlBeginIt_(avlTree);
       12:  148-block  0
    99580:  149:    for (size_t i = 0; i < lenArray; ++i) {
    99580:  149-block  0
    99568:  150:        array[i] = avlGetDataByIt(it);
    99568:  150-block  0
    99568:  151:        it = avlNextIt_(it);
        -:  152:    }
       12:  153:    return AVLERR_OK;
       12:  153-block  0
        -:  154:}
        -:  155:
        4:  156:enum AvlError_t avlForEach(struct AVL_Tree* avlTree, void (*foo)(struct Node_t* it, void* data), void* data) {
        4:  157:    if (!avlTree) {
        4:  157-block  0
        1:  158:        return AVLERR_NOT_INIT;
        1:  158-block  0
        -:  159:    }
        3:  160:    if (!foo) {
        3:  160-block  0
        1:  161:        return AVLERR_NULL_POINTER_ARG;
        1:  161-block  0
        -:  162:    }
        2:  163:    if (!avlTree->top_) {
        2:  163-block  0
        1:  164:        return AVLERR_OK;
        1:  164-block  0
        -:  165:    }
        1:  166:    struct Node_t* it = avlBeginIt_(avlTree);
        1:  166-block  0
        6:  167:    for (size_t i = 0; i < avlSize(avlTree); ++i) {
        6:  167-block  0
        5:  168:        foo(it, data);
        5:  168-block  0
        5:  169:        it = avlNextIt_(it);
        -:  170:    }
        1:  171:    return AVLERR_OK;
        1:  171-block  0
        -:  172:}
        -:  173:
        -:  174:
        -:  175://struct Node_t* avlPrevIt_(struct Node_t* it) {
        -:  176://    if (it == NULL) {
        -:  177://        return it;
        -:  178://    }
        -:  179://    if (it->prev_ == NULL) {
        -:  180://        it = it->left_;
        -:  181://        struct Node_t* tmp = it;
        -:  182://        while (it != NULL) {
        -:  183://            tmp = it;
        -:  184://            it = it->right_;
        -:  185://        }
        -:  186://        return tmp;
        -:  187://    }
        -:  188://    if (it->left_ != NULL) {
        -:  189://        it = it->left_;
        -:  190://        struct Node_t* tmp = it;
        -:  191://        while (it != NULL) {
        -:  192://            tmp = it;
        -:  193://            it = it->right_;
        -:  194://        }
        -:  195://        return tmp;
        -:  196://    }
        -:  197://    if (it->prev_->right_ == it) {
        -:  198://        it = it->prev_;
        -:  199://        return it;
        -:  200://    }
        -:  201://    if (it->prev_ == NULL) {
        -:  202://        it = it->left_;
        -:  203://        return it;
        -:  204://    }
        -:  205://    if (it->prev_->left_ == it) {
        -:  206://        struct Node_t* tmp = it->prev_;
        -:  207://        while (tmp->prev_ != NULL && tmp->prev_->right_ == tmp) {
        -:  208://            tmp = tmp->prev_;
        -:  209://        }
        -:  210://        if (tmp->prev_ == NULL) {
        -:  211://            it = NULL;
        -:  212://            return it;
        -:  213://        }
        -:  214://        it = tmp->prev_->left_;
        -:  215://        return it;
        -:  216://    }
        -:  217://    assert(1 && "Ooooops");
        -:  218://    return it;
        -:  219://}
