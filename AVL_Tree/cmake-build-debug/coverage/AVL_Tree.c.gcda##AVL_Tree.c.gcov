        -:    0:Source:/home/minerkow/Рабочий стол/CS_Programm/AVL_Tree/source/AVL_Tree.c
        -:    0:Graph:/home/minerkow/Рабочий стол/CS_Programm/AVL_Tree/cmake-build-debug/CMakeFiles/AVL_Tree_Test.dir/source/AVL_Tree.c.gcno
        -:    0:Data:/home/minerkow/Рабочий стол/CS_Programm/AVL_Tree/cmake-build-debug/CMakeFiles/AVL_Tree_Test.dir/source/AVL_Tree.c.gcda
        -:    0:Runs:1
        -:    1:#include "../headers/AVL_Tree.h"
        -:    2:#include "../headers/Error.h"
        -:    3:#include "../headers/TestHelper.h"
        -:    4:
        -:    5:
        -:    6:struct Node_t {
        -:    7:    struct Node_t* left_;
        -:    8:    struct Node_t* right_;
        -:    9:    struct Node_t* prev_;
        -:   10:
        -:   11:    int height_;
        -:   12:
        -:   13:    int data_;
        -:   14:};
        -:   15:
        -:   16:struct AVL_Tree {
        -:   17:    struct Node_t* top_;
        -:   18:
        -:   19:    size_t size_;
        -:   20:};
        -:   21:
        -:   22://-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        -:   23:
        -:   24:static struct Node_t* avlSmallLeftRotation_ (struct AVL_Tree* avlTree, struct Node_t* top); //TODO:Unit tests
        -:   25:
        -:   26:static struct Node_t* avlBigLeftRotation_ (struct AVL_Tree* avlTree, struct Node_t* top); //TODO:Unit tests
        -:   27:
        -:   28:static struct Node_t* avlSmallRightRotation_ (struct AVL_Tree* avlTree, struct Node_t* top); //TODO:Unit tests
        -:   29:
        -:   30:static struct Node_t* avlBigRightRotation_ (struct AVL_Tree* avlTree, struct Node_t* top); //TODO
        -:   31:
        -:   32:static int avlGetBalanceFactor_(struct Node_t* top);
        -:   33:
        -:   34:static struct Node_t* avlCreateNode_(struct AVL_Tree* avlTree, int data);
        -:   35:
        -:   36:static struct Node_t* avlBalancing_(struct AVL_Tree* avlTree, struct Node_t* top);
        -:   37:
        -:   38:static enum AvlError_t avlNodeBalancing_(struct Node_t* node);
        -:   39:
        -:   40://*Erase elem by pointer
        -:   41:static enum AvlError_t avlEraseByIt_(struct AVL_Tree* avlTree, struct Node_t* it);
        -:   42:
        -:   43://*If the data is in the table, it returns an iterator on it,
        -:   44://*otherwise it returns a null iterator
        -:   45:struct Node_t* avlFind_(struct AVL_Tree* avlTree, int data);
        -:   46:
        -:   47:static void avlPrintNode_ (struct Node_t* top);
        -:   48:
        -:   49:static int avlNodeHeight_(struct Node_t* top);
        -:   50:static void avlInorder_(struct Node_t* top);
        -:   51://------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        -:   52:
   100130:   53:enum AvlError_t avlInsert(struct AVL_Tree* avlTree, int data) {
   100130:   54:    if (avlTree == NULL) {
   100130:   54-block  0
        1:   55:        return AVLERR_NOT_INIT;
        1:   55-block  0
        -:   56:    }
   100129:   57:    if (avlTree->top_ == NULL) {
   100129:   57-block  0
       21:   58:        avlTree->top_ = avlCreateNode_(avlTree, data);
       21:   58-block  0
       21:   59:        if (!avlTree->top_) {
        2:   60:            return AVLERR_INSERT;
        2:   60-block  0
        -:   61:        }
       19:   62:        avlTree->top_->prev_ = NULL;
       19:   63:        return AVLERR_OK;
       19:   63-block  0
        -:   64:    }
   100108:   65:    struct Node_t* tmp = avlTree->top_;
   100108:   66:    struct Node_t* current = avlTree->top_;
  1645174:   67:    while (tmp != NULL) {
   100108:   67-block  0
  1645174:   67-block  1
  1545594:   68:        current = tmp;
  1545594:   69:        if (data > tmp->data_) {
  1545594:   69-block  0
   766746:   70:            tmp = tmp->right_;
   766746:   71:            continue;
   766746:   71-block  0
        -:   72:        }
   778848:   73:        if (data < tmp->data_) {
   778848:   73-block  0
   778320:   74:            tmp = tmp->left_;
   778320:   75:            continue;
   778320:   75-block  0
        -:   76:        }
      528:   77:        if (data == tmp->data_) {
      528:   77-block  0
      528:   78:            return AVLERR_OK;
      528:   78-block  0
        -:   79:        }
        -:   80:    }
    99580:   81:    struct Node_t* newNode = avlCreateNode_(avlTree, data);
    99580:   81-block  0
    99580:   82:    if (!newNode) {
        1:   83:        return AVLERR_INSERT;
        1:   83-block  0
        -:   84:    }
    99579:   85:    newNode->prev_ = current;
        -:   86:
    99579:   87:    if (data > current->data_) {
    99579:   87-block  0
    49622:   88:        current->right_ = newNode;
    49622:   88-block  0
        -:   89:    } else {
    49957:   90:        current->left_ = newNode;
    49957:   90-block  0
        -:   91:    }
    99579:   92:    avlNodeBalancing_(current);
    99579:   92-block  0
        -:   93:
  1683889:   94:    while (current != NULL) {
  1683889:   94-block  0
  1584310:   95:        current = avlBalancing_(avlTree, current);
  1584310:   95-block  0
        -:   96:
  1584310:   97:        current = current->prev_;
        -:   98:    }
    99579:   99:    return AVLERR_OK;
    99579:   99-block  0
        -:  100:}
        -:  101:
        9:  102:struct Node_t* avlFind_(struct AVL_Tree* avlTree, int data) {
       9*:  103:    assert(avlTree);
        9:  103-block  0
    %%%%%:  103-block  1
        -:  104:
        9:  105:    struct Node_t* tmp = avlTree->top_;
        -:  106:
       20:  107:    while (tmp != NULL) {
        9:  107-block  0
       20:  107-block  1
       19:  108:        if (data > tmp->data_) {
       19:  108-block  0
        3:  109:            tmp = tmp->right_;
        3:  110:            continue;
        3:  110-block  0
        -:  111:        }
       16:  112:        if (data < tmp->data_) {
       16:  112-block  0
        8:  113:            tmp = tmp->left_;
        8:  114:            continue;
        8:  114-block  0
        -:  115:        }
        8:  116:        if (data == tmp->data_) {
        8:  116-block  0
        8:  117:            return tmp;
        8:  117-block  0
        -:  118:        }
        -:  119:    }
        1:  120:    return NULL;
        1:  120-block  0
        -:  121:}
        -:  122:
        4:  123:bool avlIsEmpty(struct AVL_Tree* avlTree) {
        4:  124:    if (avlTree == NULL) {
        4:  124-block  0
        1:  125:        return true;
        1:  125-block  0
        -:  126:    }
        3:  127:    if (avlTree->top_ == NULL) {
        3:  127-block  0
        2:  128:        return true;
        2:  128-block  0
        -:  129:    }
        1:  130:    return false;
        1:  130-block  0
        -:  131:}
        -:  132:
    99601:  133:struct Node_t* avlCreateNode_(struct AVL_Tree* avlTree, int data) {
    99601:  134:    struct Node_t* node = (struct Node_t*)CALLOC(1, sizeof(struct Node_t));
    99601:  134-block  0
    99601:  135:    if (node == NULL) {
        3:  136:        return NULL;
        3:  136-block  0
        -:  137:    }
    99598:  138:    node->data_ = data;
    99598:  139:    node->height_ = 1;
    99598:  140:    avlTree->size_++;
    99598:  141:    return node;
    99598:  141-block  0
        -:  142:}
        -:  143:
  1584316:  144:struct Node_t* avlBalancing_(struct AVL_Tree* avlTree, struct Node_t* top) {
 1584316*:  145:    assert(top);
  1584316:  145-block  0
    %%%%%:  145-block  1
  1584316:  146:    avlNodeBalancing_(top);
  1584316:  146-block  0
        -:  147:
  1584316:  148:    struct Node_t *previous = top->prev_;
  1584316:  149:    int place = 0;
  1584316:  150:    if (previous != NULL) {
  1484711:  151:        if (previous->right_ == top) {
  1484711:  151-block  0
   736557:  152:            place = 1;
   736557:  152-block  0
        -:  153:        } else {
   748154:  154:            place = -1;
   748154:  154-block  0
        -:  155:        }
        -:  156:    }
        -:  157:
  1584316:  158:    if (avlGetBalanceFactor_(top) == 2) {
  1584316:  158-block  0
    23073:  159:        if (avlGetBalanceFactor_(top->right_) >= 0) {
    23073:  159-block  0
    11510:  160:            struct Node_t *tmp = avlSmallLeftRotation_(avlTree, top);
    11510:  160-block  0
   11510*:  161:            assert(tmp);
    %%%%%:  161-block  0
    11510:  162:            if (place == 1) {
    11510:  162-block  0
     6204:  163:                previous->right_ = tmp;
     6204:  163-block  0
        -:  164:            }
    11510:  165:            if (place == -1) {
    11510:  165-block  0
     5284:  166:                previous->left_ = tmp;
     5284:  166-block  0
        -:  167:            }
        -:  168:        } else {
    11563:  169:            struct Node_t *tmp = avlBigLeftRotation_(avlTree, top);
    11563:  169-block  0
   11563*:  170:            assert(tmp);
    %%%%%:  170-block  0
    11563:  171:            if (place == 1) {
    11563:  171-block  0
     6232:  172:                previous->right_ = tmp;
     6232:  172-block  0
        -:  173:            }
    11563:  174:            if (place == -1) {
    11563:  174-block  0
     5331:  175:                previous->left_ = tmp;
     5331:  175-block  0
        -:  176:            }
        -:  177:        }
        -:  178:    }
        -:  179:
  1584316:  180:    if (avlGetBalanceFactor_(top) == -2) {
  1584316:  180-block  0
    23413:  181:        if (avlGetBalanceFactor_(top->left_) <= 0) {
    23413:  181-block  0
    11782:  182:            struct Node_t *tmp = avlSmallRightRotation_(avlTree, top);
    11782:  182-block  0
   11782*:  183:            assert(tmp);
    %%%%%:  183-block  0
    11782:  184:            if (place == 1) {
    11782:  184-block  0
     5360:  185:                previous->right_ = tmp;
     5360:  185-block  0
        -:  186:            }
    11782:  187:            if (place == -1)
    11782:  187-block  0
     6421:  188:                previous->left_ = tmp;
     6421:  188-block  0
        -:  189:        } else {
    11631:  190:            struct Node_t *tmp = avlBigRightRotation_(avlTree, top);
    11631:  190-block  0
   11631*:  191:            assert(tmp);
    %%%%%:  191-block  0
    11631:  192:            if (place == 1) {
    11631:  192-block  0
     5298:  193:                previous->right_ = tmp;
     5298:  193-block  0
        -:  194:            }
    11631:  195:            if (place == -1) {
    11631:  195-block  0
     6333:  196:                previous->left_ = tmp;
     6333:  196-block  0
        -:  197:            }
        -:  198:    }
        -:  199:}
        -:  200:    assert(1 && "Oooops");
  1584316:  201:    return top;
  1584316:  201-block  0
        -:  202:}
        -:  203:
        -:  204:
        -:  205:///
        -:  206:///         nA                                nB
        -:  207:///       /    \                            /    \
        -:  208:///     nL      nB         ---->           nA    nR
        -:  209:///            /  \                       /  \
        -:  210:///           nC    nR                   nL  nC
        -:  211:///
    11510:  212:struct Node_t* avlSmallLeftRotation_ (struct AVL_Tree* avlTree, struct Node_t* top) {
   11510*:  213:    assert(top);
    11510:  213-block  0
    %%%%%:  213-block  1
   11510*:  214:    assert(avlTree);
    11510:  214-block  0
    %%%%%:  214-block  1
        -:  215:
    11510:  216:    struct Node_t* nA = top;
    11510:  217:    struct Node_t* nB = top->right_;
   11510*:  218:    assert(nB);
    11510:  218-block  0
    %%%%%:  218-block  1
        -:  219:
    11510:  220:    struct Node_t* nC = nB->left_;
        -:  221:
    11510:  222:    nB->prev_ = top->prev_;
    11510:  223:    nB->left_ = nA;
        -:  224:
    11510:  225:    nA->prev_ = nB;
    11510:  226:    nA->right_ = nC;
        -:  227:
    11510:  228:    if (nC != NULL) {
    11510:  228-block  0
     4426:  229:        nC->prev_ = nA;
     4426:  229-block  0
        -:  230:    }
        -:  231:
    11510:  232:    avlNodeBalancing_(nA);
    11510:  232-block  0
        -:  233:
    11510:  234:    avlNodeBalancing_(nB);
        -:  235:
    11510:  236:    if (nB->prev_ == NULL) {
       22:  237:        avlTree->top_ = nB;
       22:  237-block  0
        -:  238:    }
        -:  239:
    11510:  240:    return nB;
    11510:  240-block  0
        -:  241:}
        -:  242:
        -:  243:///
        -:  244:///     nA                               nC
        -:  245:///   /    \                           /    \
        -:  246:///  nL     nB          ---->         nA     nB
        -:  247:///        /  \                      /  \   /  \
        -:  248:///       nC   nR                   nL  nM nN   nR
        -:  249:///      /  \
        -:  250:///     nM  nN
        -:  251:///
    11563:  252:struct Node_t* avlBigLeftRotation_ (struct AVL_Tree* avlTree, struct Node_t* top) {
   11563*:  253:    assert(top);
    11563:  253-block  0
    %%%%%:  253-block  1
   11563*:  254:    assert(avlTree);
    11563:  254-block  0
    %%%%%:  254-block  1
        -:  255:
    11563:  256:    struct Node_t* nA = top;
    11563:  257:    struct Node_t* nB = top->right_;
        -:  258:
   11563*:  259:    assert(nB);
    11563:  259-block  0
    %%%%%:  259-block  1
        -:  260:
    11563:  261:    struct Node_t* nC = nB->left_;
        -:  262:
   11563*:  263:    assert(nC);
    11563:  263-block  0
    %%%%%:  263-block  1
        -:  264:
    11563:  265:    struct Node_t* nM = nC->left_;
    11563:  266:    struct Node_t* nN = nC->right_;
        -:  267:
    11563:  268:    nC->prev_ = top->prev_;
    11563:  269:    nC->left_ = nA;
    11563:  270:    nC->right_ = nB;
        -:  271:
    11563:  272:    nA->prev_ = nC;
    11563:  273:    nA->right_ = nM;
        -:  274:
    11563:  275:    nB->prev_ = nC;
    11563:  276:    nB->left_ = nN;
        -:  277:
    11563:  278:    if (nM != NULL) {
    11563:  278-block  0
     3243:  279:        nM->prev_ = nA;
     3243:  279-block  0
        -:  280:    }
    11563:  281:    if (nN != NULL) {
    11563:  281-block  0
     3200:  282:        nN->prev_ = nB;
     3200:  282-block  0
        -:  283:    }
        -:  284:
    11563:  285:    avlNodeBalancing_(nA);
    11563:  285-block  0
        -:  286:
    11563:  287:    avlNodeBalancing_(nB);
        -:  288:
    11563:  289:    avlNodeBalancing_(nC);
        -:  290:
    11563:  291:    if (nC->prev_ == NULL) {
    #####:  292:        avlTree->top_ = nC;
    %%%%%:  292-block  0
        -:  293:    }
        -:  294:
    11563:  295:    return nC;
    11563:  295-block  0
        -:  296:}
        -:  297:
        -:  298:
        -:  299:///
        -:  300:///         nA                                nB
        -:  301:///       /    \                            /    \
        -:  302:///     nB      nR         ---->           nL    nA
        -:  303:///    /  \                                     /  \
        -:  304:///   nL   nC                                  nC   nR
        -:  305:///
    11782:  306:struct Node_t* avlSmallRightRotation_ (struct AVL_Tree* avlTree, struct Node_t* top) {
   11782*:  307:    assert(avlTree);
    11782:  307-block  0
    %%%%%:  307-block  1
   11782*:  308:    assert(top);
    11782:  308-block  0
    %%%%%:  308-block  1
        -:  309:
    11782:  310:    struct Node_t *nA = top;
    11782:  311:    struct Node_t *nB = top->left_;
        -:  312:
   11782*:  313:    assert(nB);
    11782:  313-block  0
    %%%%%:  313-block  1
        -:  314:
    11782:  315:    struct Node_t* nC = nB->right_;
        -:  316:
    11782:  317:    nB->prev_ = top->prev_;
    11782:  318:    nB->right_ = nA;
        -:  319:
    11782:  320:    nA->prev_ = nB;
    11782:  321:    nA->left_ = nC;
        -:  322:
    11782:  323:    if (nC != NULL) {
    11782:  323-block  0
     4579:  324:        nC->prev_ = nA;
     4579:  324-block  0
        -:  325:    }
        -:  326:
    11782:  327:    avlNodeBalancing_(nA);
    11782:  327-block  0
        -:  328:
    11782:  329:    avlNodeBalancing_(nB);
        -:  330:
    11782:  331:    if (nB->prev_ == NULL) {
        1:  332:        avlTree->top_ = nB;
        1:  332-block  0
        -:  333:    }
        -:  334:
    11782:  335:    return nB;
    11782:  335-block  0
        -:  336:}
        -:  337:
        -:  338:
        -:  339:
        -:  340:///
        -:  341:///       nA                               nC
        -:  342:///     /    \                           /    \
        -:  343:///    nB     nR          ---->         nB     nA
        -:  344:///   /  \                             /  \   /  \
        -:  345:///  nL   nC                          nL  nM nN   nR
        -:  346:///      /  \
        -:  347:///     nM  nN
        -:  348:///
    11631:  349:struct Node_t* avlBigRightRotation_ (struct AVL_Tree* avlTree, struct Node_t* top) {
   11631*:  350:    assert(avlTree);
    11631:  350-block  0
    %%%%%:  350-block  1
   11631*:  351:    assert(top);
    11631:  351-block  0
    %%%%%:  351-block  1
        -:  352:
    11631:  353:    struct Node_t* nA = top;
    11631:  354:    struct Node_t* nB = nA->left_;
        -:  355:
   11631*:  356:    assert(nB);
    11631:  356-block  0
    %%%%%:  356-block  1
        -:  357:
    11631:  358:    struct Node_t* nC = nB->right_;
        -:  359:
   11631*:  360:    assert(nC);
    11631:  360-block  0
    %%%%%:  360-block  1
        -:  361:
    11631:  362:    struct Node_t* nM = nC->left_;
    11631:  363:    struct Node_t* nN = nC->right_;
        -:  364:
    11631:  365:    nC->prev_ = top->prev_;
    11631:  366:    nC->right_ = nA;
    11631:  367:    nC->left_ = nB;
        -:  368:
    11631:  369:    nB->right_ = nM;
    11631:  370:    if (nM != NULL) {
    11631:  370-block  0
     3235:  371:        nM->prev_ = nB;
     3235:  371-block  0
        -:  372:    }
        -:  373:
    11631:  374:    nA->left_ = nN;
    11631:  375:    if (nN != NULL) {
    11631:  375-block  0
     3316:  376:        nN->prev_ = nA;
     3316:  376-block  0
        -:  377:    }
        -:  378:
    11631:  379:    nA->prev_ = nC;
    11631:  380:    nB->prev_ = nC;
        -:  381:
    11631:  382:    avlNodeBalancing_(nB);
    11631:  382-block  0
        -:  383:
    11631:  384:    avlNodeBalancing_(nA);
        -:  385:
    11631:  386:    avlNodeBalancing_(nC);
        -:  387:
    11631:  388:    if (nC->prev_ == NULL) {
    #####:  389:        avlTree->top_ = nC;
    %%%%%:  389-block  0
        -:  390:    }
        -:  391:
    11631:  392:    return nC;
    11631:  392-block  0
        -:  393:}
        -:  394:
  3215118:  395:int avlGetBalanceFactor_(struct Node_t* top) {
 3215118*:  396:    assert(top);
  3215118:  396-block  0
    %%%%%:  396-block  1
  3215118:  397:    int balanceFactor = 0;
  3215118:  398:    balanceFactor = avlNodeHeight_(top->right_) -
  3215118:  398-block  0
  3215118:  399:                    avlNodeHeight_(top->left_);
  3215118:  400:    return balanceFactor;
        -:  401:}
        -:  402:
       27:  403:struct AVL_Tree* avlInit() {
       27:  404:    struct AVL_Tree* avlTree = (struct AVL_Tree*)CALLOC(1, sizeof(struct AVL_Tree));
       27:  404-block  0
       27:  405:    if (avlTree == NULL) {
        1:  406:        return NULL;
        1:  406-block  0
        -:  407:    }
       26:  408:    avlTree->size_ = 0;
       26:  409:    return avlTree;
       26:  409-block  0
        -:  410:}
        -:  411:
  1800061:  412:enum AvlError_t avlNodeBalancing_(struct Node_t* node) {
 1800061*:  413:    assert(node);
  1800061:  413-block  0
    %%%%%:  413-block  1
  3600122:  414:    if (avlNodeHeight_(node->right_) >
  1800061:  414-block  0
  1800061:  415:                        avlNodeHeight_(node->left_)) {
   399664:  416:        node->height_ = avlNodeHeight_(node->right_) + 1;
   399664:  416-block  0
        -:  417:    } else {
  1400397:  418:        node->height_ = avlNodeHeight_(node->left_) + 1;
  1400397:  418-block  0
        -:  419:    }
  1800061:  420:    return AVLERR_OK;
  1800061:  420-block  0
        -:  421:}
        -:  422:
       12:  423:size_t avlSize(struct AVL_Tree* avlTree) {
       12:  424:    if (avlTree == NULL) {
       12:  424-block  0
        1:  425:        return 0;
        1:  425-block  0
        -:  426:    }
       11:  427:    return avlTree->size_;
       11:  427-block  0
        -:  428:}
        -:  429:
       10:  430:enum AvlError_t avlEraseByValue(struct AVL_Tree* avlTree, int data) {
       10:  431:    if (avlTree == NULL) {
       10:  431-block  0
        1:  432:        return AVLERR_NULL_POINTER_ARG;
        1:  432-block  0
        -:  433:    }
        9:  434:    struct Node_t* it = avlFind_(avlTree, data);
        9:  434-block  0
        9:  435:    if (it == NULL) {
        1:  436:        return AVLERR_OK;
        1:  436-block  0
        -:  437:    }
        8:  438:    return avlEraseByIt_(avlTree, it);
        8:  438-block  0
        -:  439:}
        -:  440:
        8:  441:enum AvlError_t avlEraseByIt_(struct AVL_Tree* avlTree, struct Node_t* it) {
       8*:  442:    assert(avlTree);
        8:  442-block  0
    %%%%%:  442-block  1
       8*:  443:    assert(it);
        8:  443-block  0
    %%%%%:  443-block  1
        -:  444:
        8:  445:    struct Node_t* ptr = it;
        8:  446:    if (ptr->left_ == NULL && ptr->right_ == NULL) {
        8:  446-block  0
        5:  446-block  1
        4:  447:        if (ptr->prev_ == NULL) {
        4:  447-block  0
        1:  448:            free(ptr);
        1:  449:            avlTree->size_--;
        1:  450:            avlTree->top_ = NULL;
        1:  451:            return AVLERR_OK;
        1:  451-block  0
        -:  452:        }
        3:  453:        if (ptr->prev_->left_ == ptr) {
        3:  453-block  0
        1:  454:            ptr->prev_->left_ = NULL;
        1:  454-block  0
        -:  455:        } else {
        2:  456:            ptr->prev_->right_ = NULL;
        2:  456-block  0
        -:  457:        }
        3:  458:        free(ptr);
        3:  459:        return AVLERR_OK;
        3:  459-block  0
        -:  460:    } else {
        4:  461:        struct Node_t* tmp = ptr->left_;
        4:  462:        struct Node_t* current = tmp;
        4:  463:        if (current == NULL) {
        4:  463-block  0
        1:  464:            avlTree->top_ = ptr->right_;
        1:  465:            ptr->right_->prev_ = NULL;
        1:  466:            free(ptr);
        1:  467:            return AVLERR_OK;
        1:  467-block  0
        -:  468:        }
        7:  469:        while (tmp != NULL) {
        3:  469-block  0
        7:  469-block  1
        4:  470:            current = tmp;
        4:  471:            tmp = tmp->right_;
        4:  471-block  0
        -:  472:        }
        -:  473:
        3:  474:        struct Node_t* prev = current->prev_;
        3:  475:        ptr->data_ = current->data_;
        -:  476:
        3:  477:        if (current->prev_->right_ == current) {
        3:  477-block  0
        1:  478:            current->prev_->right_ = current->left_;
        1:  478-block  0
        -:  479:        }
        3:  480:        if (current->prev_->left_ == current) {
        3:  480-block  0
        2:  481:            current->prev_->left_ = current->left_;
        2:  481-block  0
        -:  482:        }
        -:  483://        if (current->left_ != NULL) {
        -:  484://            current->left_->prev_ = current->prev_;
        -:  485://        }
        3:  486:        current->left_ = NULL;
        3:  487:        current->right_ = NULL;
        -:  488:
        3:  489:        free(current);
        3:  490:        avlTree->size_--;
        -:  491:
        4:  492:        while (prev != ptr) {
        3:  492-block  0
        4:  492-block  1
        1:  493:            avlBalancing_(avlTree, prev);
        1:  493-block  0
        1:  494:            prev = prev->prev_;
        -:  495:        }
        -:  496:    }
        3:  497:    struct Node_t* tmp = ptr;
        8:  498:    while (tmp != NULL) {
        3:  498-block  0
        8:  498-block  1
        5:  499:        tmp = avlBalancing_(avlTree, tmp);
        5:  499-block  0
        5:  500:        tmp = tmp->prev_;
        -:  501:    }
        3:  502:    return AVLERR_OK;
        3:  502-block  0
        -:  503:}
        -:  504:
 11830419:  505:int avlNodeHeight_(struct Node_t* top) {
 11830419:  506:    if (top == NULL) {
 11830419:  506-block  0
   605440:  507:        return 0;
   605440:  507-block  0
        -:  508:    } else {
 11224979:  509:        return top->height_;
 11224979:  509-block  0
        -:  510:    }
        -:  511:}
        -:  512:
       28:  513:int avlClear(struct AVL_Tree* avlTree) {
       28:  514:    if (!avlTree) {
       28:  514-block  0
        2:  515:        return -1;
        2:  515-block  0
        -:  516:    }
       26:  517:    avlInorder_(avlTree->top_);
       26:  517-block  0
       26:  518:    free(avlTree);
       26:  519:    return 1;
        -:  520:}
        -:  521:
   199206:  522:void avlInorder_(struct Node_t* top) {
   199206:  523:    if (top == NULL)
   199206:  523-block  0
    99616:  524:        return;
    99616:  524-block  0
    99590:  525:    avlInorder_(top->left_);
    99590:  525-block  0
    99590:  526:    avlInorder_(top->right_);
    99590:  527:    free(top);
        -:  528:}
        -:  529:
        -:  530://void avlPerror(enum AvlError_t err) {
        -:  531://    switch (err) {
        -:  532://        case AVLERR_NOT_INIT:
        -:  533://            fprintf(stderr, "AVL: AVL Tree don't init\n"); return;
        -:  534://        case AVLERR_NULL_POINTER_ARG:
        -:  535://            fprintf(stderr, "AVL: NULL argument is supplied as an argument\n"); return;
        -:  536://        case AVLERR:
        -:  537://            fprintf(stderr, "AVL: Error\n"); return;
        -:  538://        case AVLERR_INSERT:
        -:  539://            fprintf(stderr, "AVL: Insert ERROR\n"); return;
        -:  540://        default:
        -:  541://            return;
        -:  542://    }
        -:  543://}
        -:  544://
        -:  545://void avlPrintTree_(struct AVL_Tree* avlTree) {
        -:  546://    avlPrintNode_(avlTree->top_);
        -:  547://}
        -:  548://
        -:  549://void avlPrintNode_(struct Node_t* top) {
        -:  550://    if (top == NULL){
        -:  551://        fprintf (stderr, "Error: top is NULL, line - %d\n", __LINE__);
        -:  552://        return;
        -:  553://    }
        -:  554://    if (top->left_ == NULL && top->right_ == NULL)
        -:  555://        return;
        -:  556://
        -:  557://    printf("%d ", top->data_);
        -:  558://
        -:  559://    if (top->left_ == NULL) {
        -:  560://        printf ("NULL ");
        -:  561://        //return;
        -:  562://    } else {
        -:  563://        printf("%d(prev: %d) ", top->left_->data_, top->left_->prev_->data_);
        -:  564://    }
        -:  565://
        -:  566://    if (top->right_ == NULL)
        -:  567://    {
        -:  568://        //printf ("_%d_", top->right->lexem.lex.num);
        -:  569://        printf("NULL ");
        -:  570://        //return;
        -:  571://    } else {
        -:  572://        printf("%d(prev: %d) ", top->right_->data_, top->right_->prev_->data_);
        -:  573://    }
        -:  574://    if (top->prev_ != NULL) {
        -:  575://        printf("prev: %d ", top->prev_->data_);
        -:  576://    } else {
        -:  577://        printf("prev: NULL ");
        -:  578://    }
        -:  579://    printf ("\n");
        -:  580://    if (top->left_ != NULL) {
        -:  581://        avlPrintNode_(top->left_);
        -:  582://    }
        -:  583://    if (top->right_ != NULL) {
        -:  584://        avlPrintNode_(top->right_);
        -:  585://    }
        -:  586://}
